"use strict";var __awaiter=this&&this.__awaiter||function(e,t,r,n){return new(r||(r=Promise))((function(i,o){function a(e){try{s(n.next(e))}catch(e){o(e)}}function c(e){try{s(n.throw(e))}catch(e){o(e)}}function s(e){var t;e.done?i(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(a,c)}s((n=n.apply(e,t||[])).next())}))},__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(exports,"__esModule",{value:!0});const react_1=__importStar(require("react")),react_dom_1=require("react-dom");exports.removeEvent=e=>{let t=Object.assign({},e());return Object.keys(t.props).forEach(e=>{if(e.startsWith("on"))try{delete t.props[e]}catch(r){Object.assign(t,{[e]:()=>null})}}),t};const ProgressiveHydration=({children:e,component:t,lazy:r=!1})=>{let n=react_1.useRef(null),[i,o]=react_1.useState(null);return react_1.useEffect(()=>{if(null===n)return;let{current:i}=n,a=new IntersectionObserver(([{isIntersecting:e}])=>__awaiter(void 0,void 0,void 0,(function*(){if(!e)return;let{default:r}=yield t();react_dom_1.hydrate(r(),i),a.disconnect()})));void 0!==e||r||__awaiter(void 0,void 0,void 0,(function*(){let{default:e}=yield t();o(exports.removeEvent(e))})),a.observe(i)},[]),react_1.default.createElement("div",{ref:n},void 0!==e?e:i)};exports.default=ProgressiveHydration;